<?php declare(strict_types=1);

namespace AutoDoc\TypeScript;

use AutoDoc\Analyzer\Scope;
use AutoDoc\Config;
use AutoDoc\DataTypes\ObjectType;
use AutoDoc\DataTypes\Type;
use AutoDoc\OpenApi\Parameter;
use AutoDoc\OpenApi\Path;
use AutoDoc\Route;
use Exception;

class RoutesExporter
{
    public function __construct(
        private Config $config,
        private string $targetFilePath,
    ) {
        $this->requestsObjectShape = new ObjectType;
        $this->responsesObjectShape = new ObjectType;
    }

    private ObjectType $requestsObjectShape;
    private ObjectType $responsesObjectShape;


    /**
     * @return array{
     *     filePath: string,
     *     exportedRequests: int,
     *     exportedResponses: int,
     * }
     */
    public function export(): array
    {
        foreach ($this->getOpenApiPaths($this->targetFilePath) as $route => $path) {
            foreach ($path->operations as $method => $operation) {
                $method = strtoupper($method);
                $requestBodyType = $operation->requestBody->content['application/json']->type ?? null;

                if ($requestBodyType) {
                    $this->addRequestBody($route, $method, $requestBodyType);
                }

                foreach ($operation->parameters ?? [] as $parameter) {
                    if ($parameter instanceof Parameter && $parameter->in === 'query' && $parameter->type) {
                        $this->addQueryParameter($route, $method, $parameter->name, $parameter->type);
                    }
                }

                foreach ($operation->responses ?? [] as $responseCode => $response) {
                    $responseType = $response->content['application/json']->type ?? null;

                    if ($responseType) {
                        $this->addResponse($route, $method, $responseCode, $responseType);
                    }
                }
            }
        }

        $typeConverter = new TypeConverter;

        $tsConfig = $this->config->getTypeScriptConfig();
        $scope = new Scope($this->config);

        $requestsTsType = $typeConverter->convertToTypeScriptType($this->requestsObjectShape, $scope, $tsConfig, '');
        $responsesTsType = $typeConverter->convertToTypeScriptType($this->responsesObjectShape, $scope, $tsConfig, '');

        $fileContents = '/**' . "\n"
            . ' * This file is auto-generated by PHP AutoDoc.' . "\n"
            . ' * Documentation: https://phpautodoc.com/docs/typescript' . "\n"
            . ' */' . "\n\n"
            . 'export type Requests = ' . $requestsTsType . "\n\n"
            . 'export type Responses = ' . $responsesTsType . "\n";

        $fullPath = null;

        foreach ($tsConfig['path_prefixes'] as $prefix => $basePath) {
            if (str_starts_with($this->targetFilePath, $prefix)) {
                $fullPath = $basePath . substr($this->targetFilePath, strlen($prefix));
                break;
            }
        }

        if ($fullPath === null) {
            throw new Exception('No matching path prefix found for path "' . $this->targetFilePath . '". Check your path_prefixes configuration.');
        }

        file_put_contents($fullPath, $fileContents);

        return [
            'filePath' => $fullPath,
            'exportedRequests' => count($this->requestsObjectShape->properties),
            'exportedResponses' => count($this->responsesObjectShape->properties),
        ];
    }


    private function addRequestBody(string $route, string $method, Type $requestBodyType): void
    {
        $this->requestsObjectShape->properties[$route] ??= (new ObjectType)->setRequired(true);
        $this->requestsObjectShape->properties[$route]->properties[$method] ??=  (new ObjectType)->setRequired(true); // @phpstan-ignore property.notFound
        $this->requestsObjectShape->properties[$route]->properties[$method]->properties['body'] = $requestBodyType->setRequired(true);
    }

    private function addQueryParameter(string $route, string $method, string $name, Type $parameterType): void
    {
        $this->requestsObjectShape->properties[$route] ??= (new ObjectType)->setRequired(true);
        $this->requestsObjectShape->properties[$route]->properties[$method] ??= (new ObjectType)->setRequired(true); // @phpstan-ignore property.notFound
        $this->requestsObjectShape->properties[$route]->properties[$method]->properties['query'] ??= (new ObjectType)->setRequired(true);
        $this->requestsObjectShape->properties[$route]->properties[$method]->properties['query']->properties[$name] = $parameterType->setRequired(true);
    }

    private function addResponse(string $route, string $method, int|string $responseCode, Type $responseType): void
    {
        $this->responsesObjectShape->properties[$route] ??= (new ObjectType)->setRequired(true);
        $this->responsesObjectShape->properties[$route]->properties[$method] ??= (new ObjectType)->setRequired(true); // @phpstan-ignore property.notFound
        $this->responsesObjectShape->properties[$route]->properties[$method]->properties[$responseCode] = $responseType->setRequired(true);
    }


    /**
     * @return array<string, Path>
     */
    private function getOpenApiPaths(string $targetFilePath): array
    {
        $routeLoader = $this->config->getRouteLoader();
        $paths = [];

        foreach ($routeLoader->getRoutes() as $route) {
            $route->uri = '/' . ltrim($route->uri, '/');
            $route->method = strtolower($route->method);

            if (! $this->isRouteAllowed($route, $targetFilePath)) {
                continue;
            }

            $operation = $routeLoader->routeToOperation($route);

            if ($operation) {
                $paths[$route->uri] ??= new Path;
                $paths[$route->uri]->operations[$route->method] = $operation;
            }
        }

        return $paths;
    }


    private function isRouteAllowed(Route $route, string $targetFilePath): bool
    {
        if (! $this->isHttpRequestMethodAllowed($route->method, $targetFilePath)) {
            return false;
        }

        foreach ($this->config->data['typescript']['export_http_requests_and_responses'][$targetFilePath]['routes'] ?? [] as $routePrefix) {
            if (str_starts_with(ltrim($route->uri, '/'), ltrim($routePrefix, '/'))) {
                return true;
            }
        }

        foreach ($this->config->data['typescript']['export_http_requests_and_responses'][$targetFilePath]['exact_routes'] ?? [] as $exactRoute) {
            if (trim($route->uri, '/') === trim($exactRoute, '/')) {
                return true;
            }
        }

        return false;
    }


    private function isHttpRequestMethodAllowed(string $method, string $targetFilePath): bool
    {
        $requestMethods = $this->config->data['typescript']['export_http_requests_and_responses'][$targetFilePath]['request_methods'] ?? null;

        if (empty($requestMethods)) {
            return true;
        }

        return in_array(strtolower($method), $requestMethods);
    }
}
